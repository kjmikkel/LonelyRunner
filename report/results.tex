\section{Results}
\label{results}
\todo{make results}
In this section I will show and discuss the most important results I have generated by testing the Geometrical and Numerical algorithm against various data-sets detailed in the last section: Prime Numbers, Sequential Numbers and Randomly generated numbers. 

For brevity's sake I have only included the most important graphs, as well as a table detailing the spread and speed of the 2 different algorithms. The complete data-sets can be found in table form in \ref{data_tables}, and is available in the projects github repository.

\subsection{Graphs}

\subsubsection{Primes}
\graph{Primes}{10}{Geo}{Even for small values its clear that the Geometrical algorithm is slower, and that there can be big differences when it runs}
\graph{Primes}{1000}{Geo}{Runners are still slower, but it is also clear that the Numerical algorithm sometimes can use a long time and have quite a spread}

\subsubsection{Sequential numbers}
\graph{Sequential}{10}{Geo}{Even for a small number of runners the Geometrical algorithm can have a very large spread}

\subsubsection{Sequential-Random}
\graph{Sequential-Random}{10}{Geo}{For small randomized values it is clear the Geometrical algorithm is slower than the Numerical algorithm. It is clear that if we remove the exceptional cases from both the Geometrical and Numerical algorithm, then the Geometrical algorithm has the largest spread}
\graph{Sequential-Random}{50}{Geo}{Again it is clear that barring the Numerical instance at index 2600, the Numerical instance is faster than the Geometrical algorithm}
\graph{Sequential-Random}{100}{Geo}{Same as the figure before, but while the Geometrical algorithm is slower compared to \ref{Sequential-Random_50_Geo}, the Numerical algorithm is almost the same}
\graph{Sequential-Random}{1000}{Geo}{Again we see that the Geometrical algorithm is both slower than the Numerical algorithm, and has the largest spread}
\graph{Sequential-Random}{1000}{Num}{}

\hide{
\subsubsection{Random}
\graph{Random}{10}{Num}{}
\graph{Random}{1000}{Geo}{}
\graph{Random}{2000}{Geo}{Again we see that the Numerical algorithm is faster than the Geometrical algorithm}
}
\subsection{Speed}
\input{./data/tables/speed_table.tex}

It is clear from these graphs that the Numerical algorithm is faster for most of the instances. 
I believe the reason for this to belong to the fundamental differences of the 2 algorithms. While both algorithms are based on exploring all possible candidates times for a time where \eqaref{eqa:lonelyRunner} is true, the Geometrical algorithm works by sweeping through the entire first round of the final runner\footnote{The runner with speed 1}, while the Numerical algorithm often is less methodical about it, depending on the 2 selected runner speeds, trying time points against \eqaref{eqa:lonelyRunner}. In practice it is clear this is a better approach than the Geometrical algorithm.
 
It however also clear that for some configurations (even when accounting for the spread), finding a time where \eqaref{eqa:lonelyRunner} is true, takes much more time than most of the other configurations for that number of runners. Two good examples of this are \figureref{Primes_1000_Geo} and \figureref{Sequential-Random_1000_Geo}. The best explanation I have been able to come up with for cases like the first is that \eqaref{eqa:lonelyRunner} depends not so much on the size of the numbers, but rather on the on the number of the runners and the interaction of the runners speeds. I believe cases like the second are caused by the input based run-time of the Numerical algorithm - if the order of the runner speeds are in such a way that a good part of list has to be searched through, then the Numerical algorithms run-time of $O(k * n^3)$ (as proved back in section \ref{proof_num} on page \pageref{proof_num}) begins to show itself.  

\subsection{Spread}
\input{./data/tables/spread_table.tex}



\subsection{Conclusion}

From the above it is clear that the Numerical algorithm is faster than the Geometrical. It is also clear from the graphs that neither of the algorithms are entirely stable, and for some configurations have both a very large execution time spread. As I have not been able to find a pattern for the configurations that have produced some of these abnormalities, I can 
