\section{Results}
\label{results}

\subsection{Introduction}
In this section I will show and discuss the most important results I have found while testing the Geometrical and Numerical algorithms. 

I will first show, and comment, on the most important graphs generated by the result of having run the Numerical and the Geometrical algorithms on the 3 data-sets detailed in the last section.

After that I will show the speed and spread tables for all 3 types of numbers (Sequential, Prime and Random), as well as the combined results for all these data-sets. I will then comment on these results, and try to draw some conclusions. The format for each tables is that I will first have the tables themselves, then mentioned which of the algorithms produced the best results (and how much faster they were than the other solution). If there are individual data points that takes longer than 1 second, then there will there will be 2 version of the above data: One where these extreme cases are included, and one where they are not. For each type of number I will first have the randomized version, then the non-randomized version, and then the combined version.

The complete, machine-readable, data-sets can be found in this projects github repository at \underline{https://github.com/kjmikkel/LonelyRunner}, in the src/data folder.

When a graph in the following contains a hyphenated ``Random'' in its title, it means that while both the Geometrical and the Numerical algorithm has been given the same input, the order of the input for the Numerical algorithm has been randomized. 

\subsection{Interesting Graphs}

\subsubsection{Sequential}
\graph{Sequential}{500}{Num_5000}{Here it is very clear that there are several configuration in the start where that takes an inordinate amount of time.}
\graph{Sequential}{500}{Geo}{After the Maximum number is greater than 1000, the Numerical algorithm is much faster than the Geometrical}

\graph{Sequential}{1000}{Num_5000}{The same as in figure \ref{Sequential_500_Num_5000} applies here, only to a greater extent - and here the cutoff is 2000 runners.}
\graph{Sequential}{1000}{Geo}{Again we see that outside of this special zone the Numerical algorithm is far far faster than the Geometrical}

The best explanation I have been able to come up with for cases like figure \ref{Sequential_500_Num_5000} and figure \ref{Sequential_1000_Num_5000} this is that \eqaref{eqa:lonelyRunner} does not so much depend on the size of the numbers, but rather on the on the number of the runners, and the interaction of the runners speeds. Clearly, in cases like the above, the Numerical algorithm must be forced to search through a large part of the possible candidate solutions, making the Numerical algorithms worst case run-time of $O(k * n^3)$\footnote{As proved back in Section \ref{proof_num} on p. \pageref{proof_num}} visible.

\subsubsection{Sequential-Random}
\graph{Sequential-Random}{500}{Num_5000}{Unlike figure \ref{Sequential_500_Num_5000} here there is only one point which takes an extreme time.}
\graph{Sequential-Random}{1000}{Num_5000}{Again we see a big difference between this and figure \ref{Sequential_1000_Num_5000}}

My best explanation for the big difference between the pairs figure\ref{Sequential_500_Num_5000}, figure \ref{Sequential_1000_Num_5000} and figure \ref{Sequential-Random_500_Num_5000} and figure \ref{Sequential-Random_1000_Num_5000} respectively, is that the randomization process removes many of the unfortunate configuration that made figure\ref{Sequential_500_Num_5000} and \ref{Sequential_1000_Num_5000}.

\subsubsection{Primes}
\graph{Primes}{30000}{Geo}{}
\graph{Primes-Random}{30000}{Num}{}

Figure \ref{Primes_30000_Geo} and \ref{Primes-Random_30000_Num} are exceptional in that they are the most noisy graphs that is produced from my data. It proves that just randomising the order of the input for the Numerical algorithm does will mean that a solution to \eqaref{eqa:lonelyRunner} will be found right off the bat, unlike what we saw in figure \ref{Sequential-Random_1000_Num_5000}.  



\subsection{Sequential Number Results}

\subsubsection*{Speed}
\FloatBarrier
\input{./data/tables/sequential-normal_speed_table.tex}
\input{./data/tables/sequential-random_speed_table.tex}
\input{./data/tables/sequential_speed_table.tex}
\FloatBarrier
\subsubsection*{Spread}
\FloatBarrier
\input{./data/tables/sequential-normal_spread_table.tex}
\input{./data/tables/sequential-random_spread_table}
\input{./data/tables/sequential_spread_table.tex}
\FloatBarrier
\subsubsection*{Analysis}
Comparing the results found in table \ref{sequential-normal_speedtable} and table \ref{sequential-random_speedtable}, we can see a clear example of that randomizing the order of the of the inputs for the Numerical algorithm can give it a better speed.

From table \ref{sequential_speedtable} it is clear that that the Geometrical algorithm proves to the be the preferable algorithm. Even if we were to find a way to exclude the extreme cases, we would only save 2 minutes by using the Numerical algorithm. Clearly it not a saving worth risking 5 hours of run-time for. 

Strangely from table \ref{sequential-normal_speedtable} and table \ref{sequential-random_speedtable} we can see that the Geometrical algorithm produces a different number of calculations that takes more than 1 second, and in both cases it is the same as the Numerical algorithm, even though the time spent in both cases does not differ that much.

\subsection{Prime Number Results}

\subsubsection*{Speed}
\label{prime_results}
\FloatBarrier
\input{./data/tables/prime-normal_speed_table.tex}
\input{./data/tables/prime-random_speed_table.tex}
\input{./data/tables/prime_speed_table.tex}
\FloatBarrier
\subsubsection*{Spread}
\FloatBarrier
\input{./data/tables/prime-normal_spread_table.tex}
\input{./data/tables/prime-random_spread_table.tex}
\input{./data/tables/prime_spread_table.tex}
\FloatBarrier
\subsubsection*{Analysis}
\label{result_prime}
It is interesting to note that Section \ref{prime_results} is the only batch of results where the Numerical algorithm is always faster than the Geometrical algorithm. I can only attribute this to the special nature of the prime numbers, as I have no other evidence. This leads one to wonder whether the Numerical algorithm could be made faster by skipping the second speed if it and the first were not prime (i.e. gcd($speed_1$, $speed_2$) = 1).

Comparing the average speeds in table \ref{prime-random_speedtable} and table \ref{prime-normal_speedtable} we can see that it is faster in the one, where the runner speeds had been randomized, clearly showing that the order of the inputs matter.

\subsection{Random Numbers results}

\subsubsection*{Speed}
\FloatBarrier
\label{random_results}
\input{./data/tables/random-normal_speed_table.tex}
\input{./data/tables/random-random_speed_table.tex}
\input{./data/tables/random_speed_table.tex}
\FloatBarrier
\subsubsection*{Spread}
\FloatBarrier
\input{./data/tables/random-normal_spread_table.tex}
\input{./data/tables/random-random_spread_table.tex}
\input{./data/tables/random_spread_table.tex}
\FloatBarrier
\subsubsection*{Analysis}
The result in table \ref{random-random_speedtable} is rather surprising. Since the random numbers tend to be rather large (since they lie between 1 and $2^{32} - 1$), I would have expected the Geometrical solution to be much slower, since more Event Points would have had to be created, inserted and removed from the Event Queue, before any of the Runners could enter the Zone.\\



\subsection{Total Results}
\subsubsection*{Speed}
\FloatBarrier
\input{./data/tables/total-normal_speed_table.tex}
\input{./data/tables/total-random_speed_table.tex}
\input{./data/tables/total_speed_table.tex}
\FloatBarrier
\subsubsection*{Spread}
\FloatBarrier
\input{./data/tables/total-random_spread_table.tex}
\input{./data/tables/total-normal_spread_table.tex}
\input{./data/tables/total_spread_table.tex}
\FloatBarrier
\subsubsection*{Analysis}
From table \ref{total_speedtable} it seems clear that using the Geometrical algorithm would be the best choice. In the best case it is much faster than the Numerical algorithm, and in the worst case it only takes about 30 min more than the Numerical algorithm. The risk of having the Numerical algorithm spend hours trying to find a solution for a single configuration makes such small saving irrelevant.  

Another fact worth noting is that while both the Numerical and the Geometrical algorithm have near the same number of calculations that takes more than 1 second, but clearly the time taken by the Numerical ones must take far longer, in for the Numerical solution to be the fastest when these are not counted.

\subsection{Conclusion}

From the above it is clear that while in most instances the Numerical algorithm is slightly faster than the Geometrical algorithm, it will sometimes take an inordinate amount of time, which in practice makes the Geometrical algorithm a far better choice.

It should also be clear that neither of the algorithms are entirely stable, and for some configurations have both a very large execution time and spread.
