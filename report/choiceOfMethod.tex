\section{Possible methods}
\label{choiceOfMethod}

\subsection{Introduction}
I will in this subsection describe the different methods I have thought of using in this project, and discuss their merits and flaws.

\begin{description}
\item[Computational Geometry:] The intuitive description of the Lonely Runner conjecture (described in the Introduction) lends itself well to a geometrical interpretation, and leads me to wonder whether an algorithm based on this fact would be efficient.

\item[Number theoretic:] The Lonely Runner conjecture is, in its original formulation, a problem from number theory. It is therefore not reasonable to assume that a number theoretic approach could lead to great speedups in calculating a possible solution.
\end{description}

\subsection{Computational Geometry}

The following solution is based on the first intuitive description of the conjecture. It is clear that we are interested in the time interval when the runners are in the Zone. However, we are interested in the time they are in the Zone - i.e. when a runner with a speed $s$ enters and leaves the Zone.\\ 

Let $s$ be the speed and $t$ be the time, then from \eqaref{eqa:lonelyRunner} we have 

\begin{equation}
\label{eqa:speedOne}
\begin{split}
s * t &= \frac{1}{n+1} \\
t &= \frac{1}{s * (n+1)}
\end{split}
\end{equation}

and 

\begin{equation}
\label{eqa:speedTwo}
\begin{split}
s * t &= \frac{n}{n+1} \\
t &= \frac{n}{s * (n+1)}
\end{split}
\end{equation}

From \eqaref{eqa:speedOne} and \eqaref{eqa:speedTwo} it is clear that the time interval for the first the runner is in the Zone will be 
\begin{displaymath}
\left[\frac{1}{s * (n+1)}, \frac{n}{s * (n+1)}\right]
\end{displaymath}

More generally, a runner with speed $s$ will be in the zone of the $k$'th time, where $k \in \N \cup \E{0}$, in the interval 

\begin{displaymath}
\left[\frac{1 + k * (n+1)}{s * (n+1)}, \frac{n + k * (n+1)}{s * (n+1)}\right] 
\end{displaymath}

So now it becomes a matter find out whether there is a time where the time intervals for all the runners overlap. To do this I propose using a horizontal Plane Sweep algorithm\footnote{For a general overview of Plane Sweep algorithms, please consult \cite{citeulike:3347056} or similar}, where the interesting cases are when a runner enters, and leaves the Zone. 

However, since the Lonely Runner conjecture has not been proved, there must be a means to terminate the algorithm if such a solution does not exist for a given configuration.

My solution to this is to introduce a ``fake'' runner to the race. This fake runner has a speed of $1$, and will only serve as a marker for when to terminate the algorithm. The intuition behind this is that based on \eqaref{eqa:lonelyRunner} - it is clear that if a solution exist it must do so for $x \in [0,1)$, and therefore if we reach the time $1$, no such solution can exist. \todo{needs proof}

\subsubsection{Event Points}
\label{eventPoints}
In this section I will discuss the role of event points in the Plane Sweep algorithm, as well as define them.

One question that has to be answered before we go any further is whether or not we will create all interesting Event Points before the main part of the algorithm starts (if indeed we can) or create some of them and let any remaining be generated at run-time. This also has implications whether a Linked-List or a heap, respectively, should be used for the Priority Queue that will contain the Event Points. Since I have already established that we do not need to produce any event points that happen after time 1, it is clear that we can create all the event points before entering the main loop.\\ 

\adDis{
Creating Event points before entering the main loop
}{
\item The advantage of creating the points in advance would be that this is a embarrassingly parallel task, which could be sped up by using modern computers multiple cores. After this the main loop could simply be run without having to dedicate any resources to creating new events.

\item It would also make the Priority Queue simpler, since instead of a heap, we could simply use a Linked List structure. 
}{
\item Since all the points are generated at the beginning, this would sharply increase the memory footprint on the system, and if implemented in a programming language without garbage collection, and would require a lot of work.

\item Also, while the event points themselves could be generated in parallel, they would still have to be inserted into Priority Queue, which would serve as a bottleneck. Even if this was done while all the other event points were still being generated, it would slow down the procedure enormously, loosing a lot of time. The Priority Queue would also still have to be sorted, which in any case would take O$(n\log(n))$, though of course a parallel version of the sort could be used.

\item If done correctly it would add quite a bit of complexity to the program
}{
Given that generating an event point should be trivial (it being a very simple data structure), one can question the worth of this implementation.
}

\adDis{
Creating event points on the fly
}{
\item It would reduce the memory footprint drastically, since new event points would only be made when needed (and after old ones had been removed).

\item Adding the new event points sequentially would also be much simpler than in the parallel version, where I would not have to protect the Priority Queue.  
}{
\item Creating each event point sequentially could potentially take a lot more time than the parallel solution.
}{
Creating the event points as needed is far simpler than the parallel version, although it is potentially slower in situations where the speed of the runners is large, or where the solution to the conjecture is close to $1$, or no solution exist. 
}

Thus I feel justified in saying that creating the event points on the fly is the preferred solution, as any possible gains by creating all the points at once would be minimal at best\footnote{It is worth noting that the insertions and removals from the Priority Queue cannot be used as an arguemnt, since the parrallel and sequential version each uses a different data structure, optimized for their operation.}, and would unduely increase the complexity of the program I would have to create. 

In order to distinguish entering and leaving the Zone, as well as the ``fake'' runner I introduce 3 different points:
\begin{description}
\item[\comStart] The first point represents the time where the runner is $\frac{1}{n + 1}$ units away from the start line. In the following algorithm the \comStart\, will contain the time it took to reach that location, and which runner it belongs to.
\item[\comEnd] The first point after the \comStart\, where the runner is $\frac{1}{n + 1}$ units away from the start line. Since \comEnd\, is the last event point for any given runner in the Priority Queue, \comEnd\, is used to signal to the algorithm that a new \comStart\, and \comEnd\, needs to be added to the Priority Queue. \comEnd\, needs to know the time its runner will pass it, the amount of time used to pass $\frac{1}{n+1}$ units, and to which runner it belongs to.
\item[\comFin] The final point in that will be processed --- its time is always set to $1$. If this point is ever reached, then there exists no solution for the given configuration of runners and speeds, and the Lonely Runner conjecture does not hold.
\end{description}

\subsubsection{Order of points}
In order to avoid any ambiguity concerning the order of the points, I will now introduce an order $\prec$. One of the degenerate cases we need to avoid is when we have (n-1) runners that are in the Zone, and the next two points are a \comEnd\, and a \comStart, both at the same time. Since the Zone is a closed set, it is clear that this instance should return a valid solution, but if \comEnd\, comes first, then the solution would not be reported - therefore \comStart\, must be placed before \comEnd. 

For the time points $p$ and $q$, $p \prec q$ iff \\

\begin{center}
$p_{time} < q_{time}$\\
or \\
$p_{time} == q_{time}$ and type($q$) == \comFin\, and type($q$) != type($p$)\\
or \\
$p_{time} == q_{time}$ and type($p$) == \comStart\, and type($q$) == \comEnd \\
or \\
$p_{time} == q_{time}$ and type($p$) == type($q$) and $p_{runner} < q_{runner}$
\end{center}

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{MakeTimePoints}
\highlights
\SetKwData{start}{startTime}
\Input{A start-time \ti and the \unit used to run $\frac{1}{(\n + 1)}$ part of the track, the number \run of the runner, and the time queue \li}
\Output{The time queue \li, with a new \startT and \eT inserted for \run as its runner}
 
Make new \startT $start$ from \start as its start-time, and \run as its runner
  
Make new \eT $end$ from \start + \unit * \n as its start-time, \unit as its speed, and \run as its runner
    
Add $start$ and $end$ to \li

\return \li
\end{algorithm}

\begin{algorithm}[H]
  \caption{FindLonelyRunnerTime}
  \highlights
  \SetKwData{and}{and}
  \Input{A list \s which contains n pairwise different speeds for n runners}
  \Output{A time \ti where all n runners are at least $\frac{1}{n + 1}$ units away from the starting line, or a \no, indicating that no such time exists}
  
  Create and initialise \li
  
\inter $\gets 0$

\n $\gets$ size(\s)

$runnerNum \gets 1$

Make \finish with time $1$ and add it to \li

\ForEach{speed $\in$ \s}{
  
  \unit $\gets \frac{1}{speed * (\n + 1)}$  
  
  \li $\gets$ MakeTimePoints(\unit, \unit, $runnerNum$, \li)
  
  $runnerNum += 1$
}

\While{\li is not empty}{
  \p $\gets$ firstPoint(\li)
  
  \If{\p is \startT}{      
      \inter $+= 1$
      
      \If{\inter == \n}{
        \return $\p_{time}$
      }
  }
  \uElseIf{\p is \eT}{
    
    \inter $-= 1$
    
    \ti $\gets \frac{2}{\p_{\unit} * (\n + 1)} + \p.\ti$
    
    \li $\gets$ MakeTimePoints(\ti, $p_{\unit}$, $p_{\run}$, \li)
  }
  \ElseIf{\p is \finish}{
    \return \no
  }
   
}
\end{algorithm}

\subsubsection{Proofs of the Geometric algorithm}
\algProof{
?
}{
It is clear that the algorithm will always terminate, since the algorithm terminates when it finds \comFin (which cannot be removed prematurely).
}{
If we analyse the algorithm amotized\todo{what is it really called - its not amotized}, the first loop of the algorithm takes $O(n\log(n))$ time, since it has to add $2n$ event points tto the Priority Queue, where each insertion taking $O(\log(n))$.\\

After the first loop, there will at most be $2n + 1$ or $O(n)$ Event Points in the Priority Queue, since each time we encounter a \comEnd, two new Event Points are added to the Priority Queue.\\ 

It is clear that the second loop is dependent on how many Event Points are processed before \comFin, at time $1$, is the minimum Event Point in the Priority Queue. For any given runner with speed $s$, it is clear that it will make a $s$ rounds before the ``fake'' runner arrives at the finnishing line, and for each round the system will have to deal with 2 Event Points --- a \comStart\; and an \comEnd. The \comStart\; event will take $O(1)$ to process, while the \comEnd\; will take $O(\log(n))$ time, as there will always be $O(n)$ Event Points in the Priority Queue. Therefore it is clear that if $k = \sum \comS$. Since all the speeds are positive and pairwise different, it is easily seen that either $k = n = 1$, or $k > n$, which means $O(k\log(n))$.
}

\subsection{Number Theory}

A Number Theory alternative to the Geometric Algorithm can be made by applying the results of \cite{invis}. I have sketched the algorithm described from \cite{invis} below. \cite{invis} studies the the function 
$$
k(D) = \sup_{x \in \R}\min_{1 \leq i \leq k}\Vert x d_i \Vert
$$
where D is a set $\E{d_1, d_2, \ldots, d_k}$ of integers. They arrive at the result that given D, $k(D)$ ``is attained for $x_0 = a /(d_i + d_j)$ for some $i \neq j$ and some positive integer a''. (Theorem 6 in \cite{invis}). It is clear that $a < k$, since if $a = k$ then $a/k$ would evaluate to $1$ and then $\Vert \frac{a}{k} d\Vert, d \in D$ would evaluate to 0, which is not a valid solution to the Lonely Runner conjecture.

\todo{Make sure you have the correct algorithm} .

\begin{algorithm}[H]
  \caption{NumericalLonelyRunner}
  \highlights
  \SetKwData{and}{and}
  \Input{A list \s which contains n pairwise different speeds for n runners}
  \Output{A time \ti such that all n runners are at least $\frac{1}{n + 1}$ units away from the starting line, or a \no, indicating that no such time exists}
  
  $n \gets size(\s)$

  \For{$i \gets 1$ \KwTo $n-1$}{
    
    $d \gets \s_i$
 
    \For{$j \gets i + 1$ \KwTo $n$}{
      
      $d^{\prime} \gets \s_j$

      $k \gets d + d^{\prime}$
      
      \For{$a \leftarrow 1$ \KwTo $k-1$}{
        
        $testValid \gets true$
        
        \ForEach{$s \in \s$}{
          
          $testValid \gets testValid\; \and\; (\Vert \frac{a}{k} * s \Vert \geq \frac{1}{n+1} )$

          \If{!$testValid$} {
            break
            }
          
        }
        
        \If{testValid}{
          
          \return $\frac{a}{k}$
          
        }
      }
    }
  }
  \return \no
\end{algorithm}

\subsubsection{Proofs for the numerical algorithm}

\algProof{
In \cite{invis} the authors prove that if the Lonely Runner conjecture holds, then the algorithm will produce a solution to it. To take care of the possible case that the Lonely Runner conjecture does not hold, I have added the last return statement, ensuring that the correct answer will always be reported.
}{
It is clear that the algorithm will always terminate, $\Vert x \Vert $ is the only function call in the algorithm, and it will always terminate.
}{
It is clear that the meat of NumericalLonelyRunner is 4 nested for-loops. The 2 first loops are dependent on each other, the third is based on the speed for the two runners that have been chosen, and the last loop goes through all the runners.\\

The first 2 loops gives us $\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}1 = n-1 + n-2 + \ldots 2 + 1$, which reduces to $O(n^2)$. The third loop must iterate $k-1$ times, where $k$ is the sum of 2 runner's speed.\\

If we are to give a worst case time, then it is clear $k$ must be the sum of the speed of the two fastest runners - so if we let $speed_1 = max(\comS)$ and $speed_2 = max(\comS \setminus \E{speed_1})$ then $k = speed_1 + speed_2$\\

And we go through the last loop $n$ times. Thus the entire algorithm runs in $O(k * n^3)$.
}
