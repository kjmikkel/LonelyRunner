
% [Conclusions are very important. Do not expect that the reader remembers everything you told him/her.
% Having stated the definitions, you can now be more specific that  in the introduction]
% * Overview what this work was about.
% * Main results and contributions
% * Comments on importance or
% * Tips for practical use [how your results or experience can help someone in practice or
%     another researcher to use your simulator or avoid pitfalls]
% * Future work. Reinforce the importance of work, but avoid giving out your ideas].

\section{Conclusion}
\label{conclusion}

\subsection{Summery}

I have in this project:
\begin{itemize}
\item Implemented and tested the Numerical method found in \cite{invis}
\item Implemented and tested a Geometrical method of my own devising.
\item Argued that if there exist a time that makes equation \eqaref{eqa:lonelyRunner} hold, then it will be rational.
\end{itemize}

\subsection{Results}
\begin{itemize}
\item Created a practical tool to verify whether or not a given runner configuration holds, or whether a range of configurations hold
\item Verified for 20 runners all possible configuration up to a max speed of \maxNumbers
\item Noted that in practice most solutions with runners with less speed than 1000000 (even if the computation of the result may require arbitery precision to ensure no aritchmic overflow occours) can be stored in a single word, and more so when 64-bit computers become mainstream.
\end{itemize}

\subsection{Future work}
\begin{description}
\item[Improved Geometrical method:] It would be interesting to see whether the Geometrical algorithm could be made faster. One way could be only investigate the intervals where the slowest runner is in the Zone. Since we only have a valid solution if all the runners are in the Zone, we must specificly have the slowest runner in the Zone. This could quite possibly dramatically reduce the required run-time, as since all creations, insertions and removals of Event Points when the runner is outside the Zone will never be made. 

Let SlowZone be the interval where the slowest runner is in the zone, then a pair of Event Points should be inserted on the heap iff at least one of \comStart and \comFin is in SlowZone. This would however separate the algorithm into 2 parts: The first part which finds the first Event Points that could be interesting, and the second part which is the same as before, only with a check that does not insert pairs of Event Points that are entirely outside the SlowZone.

\item[Parallelism:] It is clear that the Numerical algorithm can take advantage of multiple threads. However, given the results, it can be debated whether this would significantly improve its run-time, given that it either finds the solution right of the bat, or has to run for several hours (in which case one might wonder whether it might be better to make a hybrid algorithm that runs both, that stops them both when a solution has been found). A better place to utilize parallelism would perhaps be in the Range test, distributing the intervals that each CPU (or indeed, computer) should check. This is especially true, since the memory peak load of the range test is very small.

\item[Verification for many different number of runners and speeds:] Since I in this project has made a verifier for whether a given configuration holds for equation \eqaref{eqa:lonelyRunner} or not, it seems that the next logical step would be to set it to verify the Lonely Runner conjecture for a large verity of runner configurations. 

\item[A study of the Numerical anomlies:] From Section \ref{results}, it is clear that there are cases where the Numerical algorithm takes an exceedingly long time to find a solution. The fact that this is most prominent in the cases where we are working with sequantial numbers (random or not), and mostly when the individual runner speeds are less than/equal to the number of runners. A study into why this happens, might make it possible to avoid these in the future, giving the Numerical algorithm a huge boost.

\item[Perform Range test performance test:] Since one of the major features of the created program is to test the range of configurations, measuring the performence of both algorithms doing this task is a logical performence test. However, due to time constraints I have been unable to do so.
\end{description}
