\section{Implementation}
\label{implementation}

In this section I will try to describe the implementation choices I have made in this project.


\subsection{Choice of programming language}
I will in this section discuss the factors that decided my choice of programming languages for this project, as well as the final choice.

I have used the following parameters to decide my choice of programming language:
\begin{description}
\item[Speed:] The point of this project is to make a program that can not only verify whether or not a given configuration of the Lonely Runner conjecture holds, but also to strengthen our belief in the Lonely Runner conjecture. The program must therefore be able to run through a large number of configurations in short time. I have based these on \url{http://shootout.alioth.debian.org/u32q/which-programming-languages-are-fastest.php}
\item[Memory footprint:] Memory is slightly less essential than speed, but if the memory footprint is smaller, then we can have more runners in a given configuration. A smaller memory footprint would also seem to indicate that the program will be faster, since less has to be allocated and cleaned up. 
\item[Already implemented data-structures:] I would rather avoid having to implement the Priority Queue, and all the bugs that could bring with it, and instead relying on a built-in implementation that has proved itself to be free of bugs.
\item[My familiarity with the language:] Familiarity with the language would enable me to get create a bug free implementation of the algorithms faster.
\end{description}

Based on these criterias I will give each programming language a value from 1 to 3, with 3 being the highest, and 1 being the smallest. 

For this project I have considered 3 programming languages: Java, Haskell and C++.

\begin{tabular}{l|c|c|c}
        & Speed & Memory & Data-structures & Familiarity \\
Java    & 2     &  1     &  3              &   3  \\
Haskell & 1     &  2     &  1              &   1  \\
C++     & 3     &  3     &  3              &   2  \\
\end{tabular}

\subsubsection{Conclusion}
Based on this I would argue that the best choice would be C++ on the grounds that it clearly scores the highest, and that it will be easy for me to implement the algorithms described in section \ref{choiceOfMethod} in the language.

\subsection{Problems during implementation}
In this section I will describe some of the major problems I encountered during my implementation of the algorithms, and what I have done to resolve them.

\subsubsection{Rounding errors}
Since the Lonely Runner conjecture in its nature deals with rational numbers, it is clear that this has to be taken into account when implementing it in a real programming language. During my earliest testing phases I quickly discovered that even if the Geometrical algorithm found a valid solution, it would not be valid according to \eqaref{eqa:lonelyRunner}. My solution to this was to make the check entirely discrete. As stated in \eqafref{eqa:lonelyRunner}, we have a Lonely Runner iff
\eqa{
\Vert w_i x\Vert \geq \frac{1}{n+1}
} 

The main problem here being $\Vert w_i x\Vert$ - however, since we can be sure that the solution will always be rational (since all the speeds are integers) we have that x can be written of the form $\frac{p}{q}$ for a given $p \in \N\cup\E{0}$ and $q \in \N$ (since all speeds must be positive and the runners cannot cover negative distance). So now we have

\eqn{
\Vert w_i * \frac{p}{q}\Vert &\geq& \frac{1}{n+1}\\
min(\frac{w_i * p mod q}{q}, 1 - \frac{w_i * p mod q}{q}) &\geq& \frac{1}{n+1}\\
min(\frac{w_i * p mod q}{q}, 1 - \frac{w_i * p mod q}{q}) * (n+1) &\geq& 1\\
}

Depending on whether \frac{w_i * p mod q}{q} or 1 - \frac{w_i * p mod q}{q} is the smallest value, the eqation then becomes

\eqa{
\frac{w_i * p mod q}{q} * (n+1) &\geq& 1\\
(w_i * p mod q) * (n+1) &\geq& q 
}

or 

\eqa{
1 - \frac{w_i * p mod q}{q} * (n+1) &\geq& 1\\
(q - (w_i * p mod q)) * (n+1) &\geq& q

\subsection{Use of real numbers in the algorithm}
As detailed in section \ref{eventPoints} I choose to implement the comparison of the Event Points through integer comparison, on the grounds that it is much faster than working with floating numbers, on most hardware. It is clear from \eqaref{eqa:integerTime} that neither side of the expression can be wholly precalculated, as it requires the other Event Point's speed, meaning that this solution trades floating point comparison with several integer multiplications. It is however clear on comparison that avoiding floating point number greatly speeds up the computation. A further optimization would be to pre-compute as much as possible - which also would save memory.

\subsection{Scalability of implementation}
\label{scale}
\todo{Find out whether it scales well}

\subsubsection{Geometrical algorithm}
In current implementation of the comparison operator is that there is a limit on the number of runners and their speeds. Let us look at the expression 
\eqa{
\label{eqa:firstCompare}
(a + k * (n+1)) * s
}
 from \eqaref{eqa:integerTime} with all the symbols mean the same as in \eqaref{eqa:integerTime}. The possible large numbers are here $a$, which in the worst case is $n$, $n$ itself and $s$. No matter which data-type we choose to represent the above expression with, it is clear there exists values for $n$ and $s$ that will cause an arthrichmic overflow.

\hide{
The best I have been able to come up with is rewriting the entire comparison to 
\eqa{
\label{eqa:secondCompare}
s_ia_j - s_ja_i \leq (n+1)(k_is_j - k_js_i)
}
which still requires $s$ to be multiplied with $a$, making the speed of the runner and the local position (which in the worst case is $n$) the bottleneck.
}

The question then becomes what the maximum allowable value becomes by \eqaref{eqa:firstCompare}. Since we are not sure whether or not the Lonely Runner Conjecture holds, we must make sure that the expression does cause arithicmitic overflow, even if the algorithm for that configuration of runners will terminate by finding the Final Event Point. We must therefore assume the maximum values for the variables that change - namely the local position $a$ and the number of rounds $k$ that the runner has run. The biggest value of $a$ is $n$ and given a speed $s$, the runner can at most run $s$ rounds before the final runner arrives at the the finishing line. Let $d$ be the maximum positive number that a given number type can represent, then to find the maximum value of $s$ with respect to $n$ and $d$, we have the expression 
\eqa{
(n + s * (n+1)) * s &=& d\\
s^2(n+1) + sn &=& d\\
s^2(n+1) + sn -d &=& 0\\
}
It is clear that this a Quadratic equation with $s$ as the unknown - using the standard technique this gets us
\eqa{
s = \frac{-n \pm \sqrt{n^2 + 4(n+1) * d}}{2(n+1)}
}
In practice we are only interested in
\eqa{
s = \lfloor\frac{-n + \sqrt{n^2 + 4(n+1) * d}}{2(n+1)}\rfloor
}
as the other answer would be negative, which would have no meaning in this context, and we are furthermore only interested in integers.

So if $n = 1000$ and $d = 2^{32}-1$ (an unsigned 32 bit integer) then $s = 2070$.

If we try to find $n$ with regards to $d$ and $s$, then we have
\eqa{
s^2n + sn + s^2 &=& d\\
n(s^2 + s) + s^2 &=& d\\
n(s^2 + s) &=& d - s^2\\
n &=& \frac{d - s^2}{s^2 + s}
}
which again becomes
\eqa{
n = \lfloor \frac{d - s^2}{s^2 + s} \rfloor
}

So if we let $s = 1000$ and $d = 2^{32}-1$ then $n = 4289$

This is rather constraining, but if we use a 64 bit integer was to be used instead, then combinations such as $n = 10^6$ and $s = 4294964$ would become possible.

Since I in \ref{specs} detailed that I wanted the program to run on a normal computer, which yet does not cover 64-bit arcitectures, I have made these, and other checks that might cause overflow, use arbitrary-precision arithmetic - limiting the possible comparisons only by the memory of the system, at the cost of speed.

\subsubsection{Numerical algorithm}
A problem in the numerical implementation is that no sum $k$ of any 2 speeds must exceed the maximum value of the numerical type used (say, $2 {32} - 1$ for 32 bit integers). Even if this is far better than the Geometrical algorithm, I have implemented arbitrary-precision arithmetic, in order to make the algorithms equal in this regard.

