\section{Implementation}
\label{implementation}

In this section I will try to describe the implementation choices I have made in this project.


\subsection{Choice of programming language}
The point of this project is to make a program that can increase our belief in the Lonely Runner conjecture. It would only do so if it could go through a large number of configurations - therefore speed becomes an issue.

For this project I have considered 3 programming languages: Java, Haskell and C++.

\subsubsection{Java}
\adDisTwo{
\item I am very comfortable with Java
\item 
}{
\item While the speed of Java has improved a lot in the recent years, it is still not the fastest language around
\item If I have to choose Java, then I will have to implement the Event Points as classes - even though they should only really be data containers.
}

\subsubsection{Haskell}
\adDisTwo{
\item Haskell is generally faster than Java, but generally less so than C++
\item It would be easy to implement the Event Points as a general data-structure
\item It would be interesting to see whether the jump to functional programming might revel any insights that might help optimize the algorithm
}{
\item As described in section \ref{choiceOfMethod}, the two algorithms cannot be implemented as written, and some interpretation will be necessary.
\item I do not feel very comfortable with Haskell, and I have not had much experience with it
}

\subsubsection{C++}  
\adDisTwo{
\item C++ is a very fast language 
\item C++'s struct data-structure is an excellent way to implement the points, without having to include classes 
}{
\item C++ is much more low level than the two other languages, so it is likely that more work has to be done
\item I would have to deal with memory management, although it is unlikely that this is going to be much of a problem in this instance
\item I am much less familiar with C++ than with Java, but more so than with Haskell
}

\subsubsection{Conclusion}
In the end I choose C++ on the grounds that it was the fastest of the 3 programming languages, that I could easily make a translation of the algorithms described in section \ref{choiceOfMethod}, and that it was familiar enough that I was sure I could implement an error free version in a reasonable time.

\subsection{Problems during implementation}
In this section I will describe some of the major problems I encountered during my implementation of the algorithms, and what I have done to resolve them.

\subsection{Rounding errors}
Since the Lonely Runner conjecture in its nature deals with real numbers, it is clear that this has to be taken into account when implementing it in a real programming language. During my earliest testing phases I quickly discovered that even if the Geometrical algorithm found a valid solution, the automated check I had set up would not accept it. My solution to this was to add $10^{-10}$ to the result from the Geometrical algorithm, when doing the comparison. I think this is justifiable on the grounds that if we are just looking for whether a legal value exist or not, then changing the result from the Geometrical algorithm does not change whether it exists or not, and if we are trying to find a legal value, then doing the Geometrical algorithm and then adding $10^{-10}$ to the position of the runner after the $\Vert result * runner\_speed \Vert$ function has been applied to the result, is still a valid algorithm.

It would, however, be interesting to see if this problem could be avoided all-together.

\subsection{Use of real numbers in the algorithm}
As detailed in section \ref{eventPoints} I choose to implement the comparison of the Event Points through integer comparison, on the grounds that it is much faster than working with floating numbers, on most hardware. It is clear from \eqaref{eqa:integerTime} that neither side of the expression can be wholly precalculated, as it requires the other Event Point's speed, meaning that this solution trades floating point comparison with several integer multiplications. It is however clear on comparison that avoiding floating point number greatly speeds up the computation. A further optimization would be to pre-compute as much as possible - which also would save memory.

\subsection{Scalability of implementation}
\label{scale}
\todo{Find out whether it scales well}

\subsubsection{Geometrical algorithm}
In current implementation of the comparison operator is that there is a limit on the number of runners and their speeds. Let us look at the expression 
\eqa{
\label{eqa:firstCompare}
(a + k * (n+1)) * s
}
 from \eqaref{eqa:integerTime} with all the symbols mean the same as in \eqaref{eqa:integerTime}. The possible large numbers are here $a$, which in the worst case is $n$, $n$ itself and $s$. No matter which data-type we choose to represent the above expression with, it is clear there exists values for $n$ and $s$ that will cause an arthrichmic overflow.

The best I have been able to come up with is rewriting the entire comparison to 
\eqa{
\label{eqa:secondCompare}
s_ia_j - s_ja_i \leq (n+1)(k_is_j - k_js_i)
}
which still requires $s$ to be multiplied with $a$, making the speed of the runner and the local position (which in the worst case is $n$) the bottleneck. A possible alternative, that I have not proved nor tried implementing, would be to make the a, the local position, $a \in \E{1, 3}$ instead of $a \in \E{1, n}$ and replace all instances of $(n+1)$ with a value greater than any found in a, say 5..

Let us calculate the maximum number allowable by \eqaref{eqa:firstCOmpare}. Since we are not sure whether or not the Lonely Runner Conjecture holds, we must make sure that the expression does cause arithicmitic overflow, even if the algorithm has terminate by finding the Final Event Point. We must therefore assume the maximum values for the variables that change - namely the local position $a$ and the number of rounds $k$ that the runner has run. The biggest value of $a$ is $n$ and given a speed $s$, the runner can at most run $s$ rounds before the final runner arrives at the the finishing line. Let $d$ be the maximum positive number that a given number type can represent, then to find the maximum value of $s$ with respect to $n$ and $d$, we have the expression 
\eqa{
(n + s * (n+1)) * s &=& d\\
s^2(n+1) + sn &=& d\\
s^2(n+1) + sn -d &=& 0\\
}
It is clear that this a Quadratic equation with $s$ as the unknown - using the standard technique this gets us
\eqa{
s = \frac{-n \pm \sqrt{n^2 + 4(n+1) * d}}{2(n+1)}
}
In practice we are only interested in
\eqa{
s = \lfloor\frac{-n + \sqrt{n^2 + 4(n+1) * d}}{2(n+1)}\rfloor
}
as the other answer would be negative, which would have no meaning in this context, and we are furthermore only interested in integers.

So if $n = 1000$ and $d = 2^{32}-1$ (an unsigned 32 bit integer) then $s = 2070$.

If we try to find $n$ with regards to $d$ and $s$, then we have
\eqa{
s^2n + sn + s^2 &=& d\\
n(s^2 + s) + s^2 &=& d\\
n(s^2 + s) &=& d - s^2\\
n &=& \frac{d - s^2}{s^2 + s}
}
which again becomes
\eqa{
n = \lfloor \frac{d - s^2}{s^2 + s} \rfloor
}

So if we let $s = 1000$ and $d = 2^{32}-1$ then $n = 4289$

This is admititly rather constraining, but if we use a 64 bit integer was to be used instead, then combinations such as $n = 10^6$ and $s = 4294964$ would become possible.

Of coures if arbitrary-precision arithmetic is used, then the algorithm is only limited by the amount of memory on the system.

\subsubsection{Numerical algorithm}
A problem in the numerical implementation is that no sum $k$ of any 2 speeds must exceed the maximum value of the numerical type used (say, $2 {32} - 1$ for 32 bit integers). This constraint is however far less severe than the one for the geometrical algorithm, as it is not constrained by the number of runners. This can again be overcome by using arbitrary-recision arithmetic.
