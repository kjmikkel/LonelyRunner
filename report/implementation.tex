\section{Implementation}
\label{implementation}

In this section I will try to describe the implementation choices I have made in this project.


\subsection{Choice of programming language}
The point of this project is to make a program that can increase our belief in the Lonely Runner conjecture. It would only do so if it could go through a large number of configurations - therefore speed becomes an issue.

For this project I have considered 3 programming languages: Java, Haskell and C++.

\subsubsection{Java}
\adDisTwo{
\item I am very comfortable with Java
\item 
}{
\item While the speed of Java has improved a lot in the recent years, it is still not the fastest language around
\item If I have to choose Java, then I will have to implement the Event Points as classes - even though they should only really be data containers.
}

\subsubsection{Haskell}
\adDisTwo{
\item Haskell is generally faster than Java, but generally less so than C++
\item It would be easy to implement the Event Points as a general data-structure
\item It would be interesting to see whether the jump to functional programming might revel any insights that might help optimize the algorithm
}{
\item As described in section \ref{choiceOfMethod}, the two algorithms cannot be implemented as written, and some interpretation will be necessary.
\item I do not feel very comfortable with Haskell, and I have not had much experience with it
}

\subsubsection{C++}  
\adDisTwo{
\item C++ is a very fast language 
\item C++'s struct data-structure is an excellent way to implement the points, without having to include classes 
}{
\item C++ is much more low level than the two other languages, so it is likely that more work has to be done
\item I would have to deal with memory management, although it is unlikely that this is going to be much of a problem in this instance
\item I am much less familiar with C++ than with Java, but more so than with Haskell
}

\subsubsection{Conclusion}
In the end I choose C++ on the grounds that it was the fastest of the 3 programming languages, that I could easily make a translation of the algorithms described in section \ref{choiceOfMethod}, and that it was familiar enough that I was sure I could implement an error free version in a reasonable time.

\subsection{Problems during implementation}
In this section I will describe some of the major problems I encountered during my implementation of the algorithms, and what I have done to resolve them.

\subsection{Rounding errors}
Since the Lonely Runner conjecture in its nature deals with real numbers, it is clear that this has to be taken into account when implementing it in a real programming language. During my earliest testing phases I quickly discovered that even if the Geometrical algorithm found a valid solution, the automated check I had set up would not accept it. My solution to this was to add $10^{-10}$ to the result from the Geometrical algorithm, when doing the comparison. I think this is justifiable on the grounds that if we are just looking for whether a legal value exist or not, then changing the result from the Geometrical algorithm does not change whether it exists or not, and if we are trying to find a legal value, then doing the Geometrical algorithm and then adding $10^{-10}$ to the position of the runner after the $\Vert result * runner\_speed \Vert$ function has been applied to the result, is still a valid algorithm.

It would, however, be interesting to see if, in a future project, this problem could be avoided all-together.

\subsection{Use of real numbers in the algorithm}
As detailed in section \ref{eventPoints} I choose to implement the comparison of the Event Points through integer comparison, on the grounds that it is much faster than working with floating numbers, on most hardware. It is clear from \eqaref{eqa:integerTime} that neither side of the expression can be wholly precalculated, as it requires the other Event Point's speed, meaning that this solution trades floating point comparison with several integer multiplications. It is however clear on comparison that avoiding floating point number greatly speeds up the computation. A further optimization would be to pre-compute as much as possible - which also would save memory.

\subsection{Scalability of implementation}
\label{scale}
\todo{Find out whether it scales well}

A problem with the current implementation of the comparison operator is that there is a limit on the number of runners and their speeds. Let us look at the expression $(a + k * (n+1)) * s$ from \eqaref{eqa:integerTime} with all the symbols mean the same as in \eqaref{eqa:integerTime}. The possible large numbers are here $a$, which in the worst case is $n$, $n$ itself and $s$. No matter which data-type we choose to represent the above expression with, it is clear there exists values for $n$ and $s$ that will cause an arthrichmic overflow.

The best I have been able to come up with is rewriting the entire comparison to $s_ia_j - s_ja_i \leq (n+1)(k_is_j - k_js_i)$, which still requires $s$ to be multiplied with $a$, making the speed of the runner and the local position the bottleneck. A possible alternative, that I have not proved nor tried implementing, would be to make the a, the local position, $a \in \E{1, 3}$ instead of $a \in \E{1, n}$ and replace all instances of $(n+1)$ with a value greater than any found in a, say 5. 
